<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:tei="http://www.tei-c.org/ns/1.0" 
  xmlns:cc="http://web.resource.org/cc/" 
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
  xmlns:dhq="http://www.digitalhumanities.org/ns/dhq"
  xmlns:fn="http://example.com/xml-functions"
  >
<!-- tei to hugo markdown, generated by chat gpt4 
This XSLT stylesheet will generate Markdown output with YAML metadata based on the TEI XML structure. 
It converts <title> and <date> elements from the TEI header into the Hugo front matter metadata. 
It also extracts <term> elements under <keywords> to generate both categories and tags metadata. 
Additionally, it converts <p>, <head>, <hi>, <code>, and <ref> elements to their corresponding Markdown equivalents.
-->

<xsl:output method="text" omit-xml-declaration="yes" />

<xsl:variable name="br" select="'&#10;'" />
<xsl:variable name="quote" select="'&quot;'" />
<xsl:variable name="lt" select="'&lt;'" />
<xsl:variable name="gt" select="'&gt;'" />

<xsl:key name="bibliog" match="//tei:bibl" use="@xml:id" />


<!-- todo: set path via xsl param? lookup relative to article? -->
<xsl:variable name="dhqtoc" select="document('../dhq-journal/toc/toc.xml')"/>

<!-- run on all from one script? 
<xsl:template name="main">
  <xsl:for-each select="collection('.?select=*.xml;recurse=yes')">
    <xsl:result-document href="out/{tokenize(document-uri(.), '/')[last()]">
      <xsl:apply-templates select="."/>
    </xsl:result-document>
  </xsl:for-each>
</xsl:template>
-->

<!-- tcsh batchrun 
foreach article ( `find ../dhq-journal/articles/ -name '*.xml'` )
foreach? echo $article
foreach? saxon $article tei-to-hugo.xslt
foreach? end


some files result in empty contents (maybe translated ones?);
find them by size:
 less `find content/vol/ -size 4c`


-->

  <xsl:function name="fn:langcode">
    <!-- convert tei language to language code; at least one case where
    'sp' is used instead of 'es' -->
    <xsl:param name="lang"/>
    <xsl:choose>
      <xsl:when test="$lang = 'sp'">es</xsl:when>
      <xsl:otherwise><xsl:value-of select="$lang"/></xsl:otherwise>
    </xsl:choose>
  </xsl:function>


  <!-- Template for the root element -->
  <xsl:template match="/">

    <!-- TODO: skip if volume is zero (sample/template xml, not real articles) -->
    <!-- TODO: skip if volume is not set. (not yet published content?) -->


    <!-- Output directory path and filename -->
    <!-- TODO: include language code in filename; 
         output multiple files for translated articles 
    see articles/000346/000346.xml for one example of an english/spanish article
    another: articles//000353/000353.xml
       -->

    <!-- <xsl:variable name="articleYear" select="substring-before($articleDate, '-')"/> -->
    <xsl:variable name="articleID" select="normalize-space(tei:TEI/tei:teiHeader//tei:publicationStmt/tei:idno[@type='DHQarticle-id'])"/>    
    <xsl:variable name="volume" select="tei:TEI/tei:teiHeader//tei:publicationStmt/ tei:idno[@type='volume']"/>    
    <xsl:variable name="issue" select="tei:TEI/tei:teiHeader//tei:publicationStmt/tei:idno[@type='issue']"/>    

    <!-- find toc for the issue that contains this article -->
    <xsl:variable name="journaltoc" select="$dhqtoc//journal[.//item/@id=$articleID]"/>
    <!-- <xsl:variable name="articletoc" select="$dhq//item[@id=$articleID]"/>     -->
    <!-- determine order within issue based on number of proceeding articles -->
    <xsl:variable name="articleOrder" select="count($journaltoc//item[following::item[@id=$articleID]]) + 1"/>   
    <xsl:variable name="preview" select="$journaltoc/@preview"/>
    <!-- get cluster if this article belongs to one -->
    <xsl:variable name="cluster" select="$journaltoc/cluster[.//item/@id=$articleID]"/>

    <!-- match dhq url structure somewhat: vol/vol#/issue#/article#/ -->
    <xsl:variable name="outputDirectory" select="concat('content/vol/', number($volume), '/', number($issue))"/>    

     <xsl:for-each select="tei:TEI/tei:teiHeader/tei:profileDesc/tei:langUsage/tei:language">
      <!-- FIXME: at least one article has a langUsage languade code but no corresponding text; check for text with language before creating ? -->

          <xsl:variable name="lang" select="@ident"/>
          <xsl:variable name="outputlang" select="fn:langcode(@ident)"/>
      <xsl:value-of select="concat('Converting language: ', $lang, ' (', @extent, ')', $br)"/>
      <!-- output into a leaf page bundle so we can include assets -->
          <xsl:variable name="outputFilename" select="concat($outputDirectory, '/', $articleID, '/index.', $outputlang, '.md')"/>


    <!-- output filename for debugging purposes -->
    <xsl:value-of select="concat($outputFilename, $br)"/>
     <!-- Output the YAML front matter and content to the specified file path -->
    <xsl:result-document href="{$outputFilename}">
    <xsl:value-of select="concat('---', $br)"/>
    <xsl:apply-templates select="/tei:TEI/tei:teiHeader">
      <xsl:with-param name="lang" select="$lang"></xsl:with-param>
      <xsl:with-param name="translationType" select="@extent"></xsl:with-param>
    </xsl:apply-templates>
    <!-- single language -->
    <xsl:apply-templates select="/tei:TEI/tei:text/tei:front">
      <xsl:with-param name="lang" select="$lang"></xsl:with-param>
    </xsl:apply-templates>
    <!-- translated or stub -->
    <xsl:apply-templates select="//tei:text/tei:group/tei:text[@xml:lang=$lang]/tei:front">
      <xsl:with-param name="lang" select="$lang"></xsl:with-param>
    </xsl:apply-templates>

    <!-- metadata based on dhq toc -->
    <xsl:value-of select="fn:field('order', string($articleOrder))"/>
    <!-- if article/issue is in preview, set hugo article to draft -->    
    <xsl:if test="$preview = 'true'">
      <xsl:value-of select="fn:field('draft', 'true')"/>
    </xsl:if>
    <xsl:if test="$cluster">    
      <xsl:value-of select="fn:quotedField('cluster', $cluster/title)"/>      
    </xsl:if>
    <!-- still todo: set cluster this article belongs to based on toc
      dhq-journal/toc/toc.xml

      - one issue can have multiple clusters
      - list cluster editors
    -->
    <xsl:value-of select="concat('---', $br)"/>

    <!-- todo: handle abstract and teaser -->

    <!-- content for current language -->
    <!-- <xsl:apply-templates select="/tei:text/tei:body"/> -->
    <xsl:apply-templates select="//tei:text[@xml:lang = $lang]/tei:body"/>    

    <!-- output bibliography (any language aware/specific ? ) -->
    <xsl:apply-templates select="//tei:back/tei:listBibl"/>    


      </xsl:result-document>

      </xsl:for-each>

  </xsl:template>

  <xsl:function name="fn:field">
    <!-- function to output data as a yaml field for hugo page metadata -->
    <xsl:param name="name"/>
    <xsl:param name="value"/>

    <xsl:value-of select="concat($name, ': ', normalize-space($value), $br)"/>
  </xsl:function>

  <xsl:function name="fn:multilineField">    
     <xsl:param name="name"/>
    <xsl:param name="value"/>
     <xsl:value-of select="concat($name, ': |', $br, '   ', normalize-space($value), $br)"/>
  </xsl:function>

  <xsl:function name="fn:quotedField">
    <!-- function to output string data, with quotes, as
      a yaml field for hugo page metadata -->    
    <xsl:param name="name"/>
    <xsl:param name="value"/>
    <xsl:choose>
      <xsl:when test="contains($value, $quote)">
        <xsl:value-of select="fn:multilineField($name, $value)"/>                
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="fn:field($name, concat($quote, normalize-space($value), $quote))"/>        
      </xsl:otherwise>
    </xsl:choose>


    <!-- TODO: handle quotes in field content -->
    <!-- <xsl:variable name="content" select="replace($value, $quote, concat('\\', $quote))"/> -->
    <!-- <xsl:value-of select="fn:field($name, concat($quote, normalize-space($value), $quote))"/>     -->

  </xsl:function>

  <!-- Template for the TEI header -->
  <xsl:template match="tei:teiHeader">
    <xsl:param name="lang"/>
    <xsl:param name="translationType"/>
    <!-- use article type for appropriate SW templates -->
    <xsl:value-of select="fn:field('type', 'article')"/>
    <!-- dhq type (article/editorial) -->
    <!-- at least one article has articletype repeated; get the first -->
    <xsl:value-of select="fn:field('dhqtype', tei:fileDesc/tei:publicationStmt/dhq:articleType[1])"/>    
    <!-- take title with language if present, but fallback to any title -->
    <xsl:value-of select="fn:quotedField('title', (tei:fileDesc/tei:titleStmt/tei:title[@xml:lang = $lang]|tei:fileDesc/tei:titleStmt/tei:title)[1])"/>
    <xsl:value-of select="fn:field('date', tei:fileDesc/tei:publicationStmt/tei:date/@when)"/>
    <!-- quote to preserve leading zeroes -->
    <xsl:value-of select="fn:quotedField('article_id', tei:fileDesc/tei:publicationStmt/tei:idno[@type='DHQarticle-id'])"/>
    <xsl:value-of select="fn:field('volume', tei:fileDesc/tei:publicationStmt/tei:idno[@type='volume'])"/>
    <xsl:value-of select="fn:field('issue', tei:fileDesc/tei:publicationStmt/tei:idno[@type='issue'])"/>

    <!-- author list -->
    <xsl:value-of select="concat('authors:', $br)"/>
    <xsl:apply-templates select="tei:fileDesc/tei:titleStmt/dhq:authorInfo" mode="metadata"/>
    <!-- todo: include translators and whether original/translation/stub -->
   <xsl:value-of select="fn:field('translationType', $translationType)"/>
    <!-- keyword lists; map dhq keywords to categories and author keywords to tags -->
    <xsl:apply-templates select="tei:profileDesc//tei:keywords[@scheme='#dhq_keywords']"/>
    <xsl:apply-templates select="tei:profileDesc//tei:keywords[@scheme='#authorial_keywords']"/>
    <!-- TODO: set license when not default -->

  </xsl:template>

  <!-- convert front matter to page metadata -->
  <xsl:template match="tei:front">
    <xsl:param name="lang" tunnel="yes"/>
    <!-- NOTE: one document (000482) has two abstracts with different language tags
    in the main text (but is not translated). But most abstracts don't have a language tag. Grab the first? -->
    <xsl:value-of select="fn:multilineField('abstract', dhq:abstract[1])"/>    
    <!-- <xsl:value-of select="fn:multilineField('abstract', dhq:abstract[@xml:lang=$lang])"/>     -->
    <xsl:value-of select="fn:quotedField('teaser', dhq:teaser)"/>        

    <!-- TODO: stub records have abstract translated only -->

  </xsl:template>


  <!-- output authors as markdown list for page yaml -->
  <xsl:template match="dhq:authorInfo" mode="metadata">
    <xsl:value-of select="concat('- ', normalize-space(dhq:author_name), $br)"/>
  </xsl:template>

  <xsl:template match="tei:keywords[@scheme='#dhq_keywords']">
    <!-- only output if there is text for at least one keyword -->
    <xsl:if test=".//tei:item/text()|.//tei:term/@corresp">
        <xsl:value-of select="concat('categories:', $br)"/>
      <xsl:apply-templates select=".//tei:item" mode="metadata"/>
      <xsl:apply-templates select=".//tei:term" mode="metadata"/>            
    </xsl:if>
  </xsl:template>

  <xsl:template match="tei:keywords[@scheme='#authorial_keywords']">
    <!-- only output if there is text for at least one keyword -->
    <xsl:if test=".//tei:item/text()|.//tei:term[@corresp]">
        <xsl:value-of select="concat('tags:', $br)"/>
        <!-- at least one article has items not nested under list -->        
      <xsl:apply-templates select=".//tei:item" mode="metadata"/>
      <xsl:apply-templates select=".//tei:term" mode="metadata"/>      
    </xsl:if>
  </xsl:template>


  <xsl:template match="tei:item" mode="metadata">
    <xsl:if test="normalize-space(.)"> <!-- don't output empty items -->
      <xsl:value-of select="concat('- ', ., $br)"/>    
    </xsl:if>
  </xsl:template>

  <xsl:template match="tei:keywords/tei:term" mode="metadata">    
    <!-- <xsl:if test="@corresp"> -->
      <!-- <xsl:value-of select="concat('- ', ., substring-after(@corresp, '#'))"/>               -->
      <xsl:value-of select="concat('- ', replace(substring-after(@corresp, '#'), '_', ' '), $br)"/>          
    <!-- </xsl:if> -->
  </xsl:template>

 

  <!-- Template for TEI keywords/terms -->
  <xsl:template match="term">
    <xsl:text>[</xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>]</xsl:text>
    <xsl:if test="position() != last()">
      <xsl:text>, </xsl:text>
    </xsl:if>
  </xsl:template>

  <!-- Template for the body -->
  <xsl:template match="tei:body">
    <xsl:apply-templates/>

    <xsl:apply-templates select=".//tei:note" mode="endnotes"/>
    <!-- todo: handle bibliography and bibliography pointers -->
  </xsl:template>

  <!-- paragraphs in markdown are indicated by line breaks -->
  <xsl:template match="tei:p|tei:div">
    <xsl:value-of select="$br"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

<!-- fixme: probably need to handle at cit/epigraph level -->
  <xsl:template match="tei:quote[@rend='block']">
    <xsl:value-of select="concat($br, '> ')"/>
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/>    
  </xsl:template>

  <xsl:template match="tei:quote[@rend='block']/tei:lb">
    <xsl:value-of select="concat($br, '> ')"/>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Template for titles -->
  <xsl:template match="tei:head">
    <xsl:value-of select="concat($br, '# ')"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

  <!-- heading inside figure should be treated differently -->
  <xsl:template match="tei:figure/tei:head">
    <xsl:apply-templates/>
  </xsl:template>

    <!-- Template for headings -->
  <xsl:template match="tei:div/tei:head">
    <xsl:value-of select="concat($br, $br, '## ')"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

<xsl:template match="tei:list">
    <xsl:value-of select="$br"/> 
    <xsl:apply-templates/>    
    <xsl:value-of select="concat($br, $br)"/>     
  </xsl:template>


<xsl:template match="tei:note">
  <xsl:value-of select="concat('[^', count(preceding::tei:note) + 1, '] ')" />
</xsl:template>

<xsl:template match="tei:note" mode="endnotes">
  <xsl:value-of select="concat($br, '[^', count(preceding::tei:note) + 1, ']: ')" />  
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="tei:ptr">
<xsl:choose>
  <xsl:when test="starts-with(@target, '#')">
    <!-- use a key to lookup the bibliography entry and get the label -->
    <xsl:variable name="label" select="key('bibliog', substring-after(@target, '#'))/@label"/>    
<!--    <xsl:value-of select="concat($lt, 'a class=', $quote, 'footnote-ref', $quote, ' href=', $quote, '#fn:', substring-after(@target, '#'), $quote, ' role=', $quote, 'doc-noteref', $quote, $gt, ' [', $label, '] ', $lt, '/a', $gt)"/>-->
    <!-- assume internal link is a bibliography ref; output as a footnote -->
    <xsl:value-of select="concat('[^', substring-after(@target, '#'), ']')"/>    
  </xsl:when>
  <xsl:otherwise>
  <!-- ptr with no text uses url for link text -->
  <xsl:value-of select="concat('[', @target, '](', @target, ')')"/>
</xsl:otherwise>
</xsl:choose>
</xsl:template>


<xsl:template match="tei:list[@type='unordered']/tei:item">
    <xsl:value-of select="concat($br, ' * ')"/> 
  <xsl:apply-templates/>      
</xsl:template>

<xsl:function name="fn:wrap">
    <xsl:param name="outer"/>
    <xsl:param name="inner"/>

    <xsl:value-of select="concat(' ' , $outer)"/>
    <xsl:for-each select="$inner">
      <xsl:apply-templates/>
    </xsl:for-each>
    <xsl:value-of select="concat($outer, ' ')"/>    
  </xsl:function>

  <xsl:function name="fn:wrap">
    <xsl:param name="firstOuter"/>
    <xsl:param name="inner"/>
    <xsl:param name="lastOuter"/>    

    <xsl:value-of select="concat(' ' , $firstOuter)"/>
    <xsl:for-each select="$inner">
      <xsl:apply-templates/>
    </xsl:for-each>
    <xsl:value-of select="concat($lastOuter, ' ')"/>    
  </xsl:function>

  <xsl:function name="fn:textparam">
    <!-- convert text for use as a shortcode parameter -->
    <xsl:param name="text"/>   
    <!-- normalize space; escape quotes -->
    <xsl:value-of select="replace(normalize-space($text), $quote, '\\&quot;')"/>
  </xsl:function>


  <!-- convert tei image figure to hugo figure shortcode -->
  <!-- FIXME: apparently PDF counts as graphic?! handle differently -->
  <!-- and one .tmp ?! -->
  <xsl:template match="tei:figure[tei:graphic]">
    <!-- generate something like this:
        {{< figure src="elephant.jpg" title="An elephant at sunset" >}} -->    

    <xsl:variable name="title">
      <xsl:apply-templates select="tei:head"/>
    </xsl:variable>
    <xsl:variable name="description">    
      <xsl:apply-templates select="tei:figDesc"/>      
    </xsl:variable>
    <!-- some figures have multiple graphics; output one shortcode for each -->
    <xsl:for-each select="tei:graphic">
      <xsl:if test="not(ends-with(@url, '.pdf'))">
      <!-- <xsl:variable name="src" select="@url"/>             -->
      <!-- 000091 and 000103 have weird relative .. paths; convert to resource only -->
      <xsl:variable name="src" select="concat('resources/', substring-after(@url, 'resources/'))"/>      
      <xsl:value-of select="concat($br, '{{', $lt, ' figure src=', $quote, $src, $quote, ' ')"/>
      <xsl:if test="$title">
        <xsl:value-of select="concat('caption=', $quote, fn:textparam($title), $quote, ' ')"/>
      </xsl:if>
      <xsl:if test="$description">
        <xsl:value-of select="concat('alt=', $quote, fn:textparam($description), $quote, ' ')"/>
      </xsl:if>
      <xsl:value-of select="concat(' ', $gt, '}}', $br, $br)"/>
    </xsl:if>
    </xsl:for-each>
  </xsl:template>

<!-- todo: handle figure with media instead of graphic; 
 <figure xml:id="figure14">
          <head>Professor Adam Banks in his Langston Hughes Visiting Professorship Lecture at the
            University of Kansas.</head>
          <media mimeType="video/mp4" url="https://player.vimeo.com/video/508958639"/>
        </figure>
{{< vimeo id="146022717" class="my-vimeo-wrapper-class" title="My vimeo video" >}}
-->
  <xsl:template match="tei:figure[tei:media]">
    <xsl:choose>
      <xsl:when test="contains(tei:media/@url, 'vimeo')">      
        <xsl:variable name="vimeo_id" select="tokenize(tei:media/@url, '/')[last()]"/>
        <xsl:value-of select="concat($br, '{{', $lt, ' vimeo id=', $quote, $vimeo_id, $quote, ' title=', $quote, fn:textparam(tei:head), $quote, ' ', $gt, '}}', $br, $br)"/>
      </xsl:when>

      <!-- todo: handle other video and audio -->

      <!-- <xsl:when test="starts-with(tei:media/@mimeType], 'video')"> -->
    </xsl:choose>
    </xsl:template>


  <xsl:template match="tei:listBibl">
    <!-- <xsl:value-of select="concat($br, $br, '## Bibliography', $br, $br, $lt, 'ul', $gt, $br)"/> -->
    <xsl:apply-templates/>
                    <!-- <bibl label="Bennett 2010" xml:id="bennett2010" key="bennett2010b">Bennett, Jane. <title rend="italic">Vibrant Matter: A Political Ecology of Things</title>. Duke University Press, Raleigh, North Carolina (2010).</bibl> -->
    <!-- <xsl:value-of select="concat($br, $lt, '/ul', $gt, $br)"/> -->
  </xsl:template>

  <xsl:template match="tei:listBibl/tei:bibl">  
    <!-- <xsl:value-of select="concat($lt, 'li id=', $quote, 'fn:', @xml:id, $quote, $gt)"/>         -->
    <!--
    <xsl:value-of select="concat($lt, 'li id=', $quote, 'fn:', @xml:id, $quote, $gt)"/>    
        <xsl:apply-templates/>
    <xsl:value-of select="concat($lt, 'a href=', $quote, '#fn:', @xml:id, $quote, ' class=', $quote, 'footnote-backref', $quote, ' role=', $quote, 'doc-backlink', $quote, $gt, '↩︎', $lt, '/a', $gt)"/>            
    <xsl:value-of select="concat($br, $lt, '/li', $gt, $br)"/>         -->

    <!-- output as markdown footnotes  -->
    <xsl:value-of select="concat($br, '[^', @xml:id, ']: ')" />  
    <xsl:apply-templates/>
   
  </xsl:template>

  <!-- links in bibl need to be html since we're generating html bibliography -->
  <!--
  <xsl:template match="tei:bibl/tei:ref">
    <xsl:variable name="label">
        <xsl:apply-templates/>
    </xsl:variable>
    <xsl:value-of select="concat($lt, 'a href=', $quote, @target, $quote, $gt, $label, $lt, '/a', $gt)"/>         
  </xsl:template> -->


  <!-- Template for emphasis -->
  <xsl:template match="tei:hi[@rend='italic']|tei:title[@rend='italic']|tei:emph|tei:bibl[@style='italic']">
    <xsl:value-of select="fn:wrap('_', .)"/>
  </xsl:template>

  <!-- Template for bold -->
  <xsl:template match="tei:hi[@rend='bold']">
    <xsl:value-of select="fn:wrap('**', .)"/>
  </xsl:template>

  <!-- Template for code -->
  <!-- todo: use <eg lang='xml'> similarly; check for others -->
  <!-- eg lang: xml, nohighlight, code-general, json, javascript, java, fortran, python, c++
  nohighlight looks like just pre-formatted text -->
  <xsl:template match="tei:code[@lang]|tei:eg">
    <!-- assuming should always be block -->
    <xsl:variable name="start">
    <xsl:choose>
      <xsl:when test="@lang = 'nohighlight' or @lang = 'code-general'">
      <xsl:value-of select="concat($br, '```', $br)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="concat($br, '```', @lang, $br)"/>
      </xsl:otherwise>
    </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="concat($br, '```', $br)"/>
    <xsl:value-of select="fn:wrap($start, ., $end)"/>    
  </xsl:template>

  <!-- code with no lang: assuming inline -->
  <xsl:template match="tei:code">
    <xsl:value-of select="fn:wrap('`', ., '`')"/>    
  </xsl:template>

   <xsl:template match="tei:soCalled|tei:quote[@rend='inline']|tei:title[@rend='quotes']">
    <xsl:value-of select="fn:wrap('“', ., '”')"/>        
  </xsl:template>

  <!-- convert links to markdown links -->
  <xsl:template match="tei:ref">
    <!-- todo: convert dhq links to dhqwords links -->
    <xsl:variable name="label">
        <xsl:apply-templates/>
    </xsl:variable>
    <xsl:variable name="target">
      <xsl:choose>
        <xsl:when test="contains(@target, '/dhq/vol/')">
          <xsl:value-of select="replace(replace(@target, '^.*/dhq/', '/dhqwords/'), '/\d+\.html$', '/')"/>
          <!-- <xsl:value-of select="replace(substring-after(@target, 'http://digitalhumanities.org/dhq'), '/\d+\.html$', '')"/>           -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="@target"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:value-of select="concat('[', $label, '](', $target, ')')"/>
  </xsl:template>

  <!-- handle tables; convert to html since easier -->
  <!-- fixme: not working... -->
  <xsl:template match="tei:table">
    <table>
      <xsl:apply-templates/>
    </table>
  </xsl:template>
  <xsl:template match="tei:table/tei:head">  
    <caption><xsl:apply-templates/></caption>
  </xsl:template>
  <xsl:template match="tei:table/tei:row">    
    <tr><xsl:apply-templates/></tr>
  </xsl:template>
  <xsl:template match="tei:table/tei:row[@role='label']/tei:cell">      
    <th><xsl:apply-templates/></th>    
  </xsl:template>
  <xsl:template match="tei:table/tei:row/tei:cell" priority="2">      
    <td><xsl:apply-templates/></td>    
  </xsl:template>


  <!-- don't normalize space inside code/eg, bibl -->
  <xsl:template match="tei:code/text()|tei:eg/text()|tei:bibl/text()">
    <xsl:apply-templates select="."/>    
  </xsl:template>

  <xsl:template match="text()" priority="2">
    <!-- normalize space, but preserve whitespace at beginning or end, to handle
    spaces around inline markup -->
    <xsl:if test="matches(., '^\s')"><xsl:value-of select="' '"/></xsl:if>
    <xsl:apply-templates select="normalize-space(.)"/>
    <xsl:if test="matches(., '\s$')"><xsl:value-of select="' '"/></xsl:if>    
  </xsl:template>

  <!-- Identity template to copy nodes as-is -->
  <xsl:template match="@*|element()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>



</xsl:stylesheet>
