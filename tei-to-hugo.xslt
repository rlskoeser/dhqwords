<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:tei="http://www.tei-c.org/ns/1.0" 
  xmlns:cc="http://web.resource.org/cc/" 
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
  xmlns:dhq="http://www.digitalhumanities.org/ns/dhq"
  xmlns:fn="http://example.com/xml-functions">
<!-- tei to hugo markdown, generated by chat gpt4 
This XSLT stylesheet will generate Markdown output with YAML metadata based on the TEI XML structure. 
It converts <title> and <date> elements from the TEI header into the Hugo front matter metadata. 
It also extracts <term> elements under <keywords> to generate both categories and tags metadata. 
Additionally, it converts <p>, <head>, <hi>, <code>, and <ref> elements to their corresponding Markdown equivalents.
-->

<xsl:output method="text" omit-xml-declaration="yes" />

<xsl:variable name="br" select="'&#10;'" />
<xsl:variable name="quote" select="'&quot;'" />

<!-- run on all from one script? 
<xsl:template name="main">
  <xsl:for-each select="collection('.?select=*.xml;recurse=yes')">
    <xsl:result-document href="out/{tokenize(document-uri(.), '/')[last()]">
      <xsl:apply-templates select="."/>
    </xsl:result-document>
  </xsl:for-each>
</xsl:template>
-->

<!-- tcsh batchrun 
foreach article ( `find ../dhq-journal/articles/ -name '*.xml'` )
foreach? echo $article
foreach? saxon $article tei-to-hugo.xslt
foreach? end


some files result in empty contents (maybe translated ones?);
find them by size:
 less `find content/vol/ -size 4c`


-->


  <!-- Template for the root element -->
  <xsl:template match="/">

    <!-- TODO: skip if volume is zero (sample/template xml, not real articles) -->
    <!-- TODO: skip if volume is not set. (not yet published content?) -->


    <!-- Output directory path and filename -->
    <!-- TODO: include language code in filename; 
         output multiple files for translated articles 
    see articles/000346/000346.xml for one example of an english/spanish article
    another: articles//000353/000353.xml
       -->



    <!-- <xsl:variable name="articleYear" select="substring-before($articleDate, '-')"/> -->
    <xsl:variable name="articleID" select="tei:TEI/tei:teiHeader//tei:publicationStmt/tei:idno[@type='DHQarticle-id']"/>    
    <xsl:variable name="volume" select="tei:TEI/tei:teiHeader//tei:publicationStmt/ tei:idno[@type='volume']"/>    
    <xsl:variable name="issue" select="tei:TEI/tei:teiHeader//tei:publicationStmt/tei:idno[@type='issue']"/>    

    <!-- match dhq url structure somewhat: vol/vol#/issue#/article#/ -->
    <xsl:variable name="outputDirectory" select="concat('content/vol/', number($volume), '/', number($issue))"/>    
    <xsl:variable name="outputFilename" select="concat($outputDirectory, '/', $articleID, '.md')"/>

    <xsl:value-of select="concat($outputFilename, $br)"/>
     <!-- Output the YAML front matter and content to the specified file path -->
    <xsl:result-document href="{$outputFilename}">
    <xsl:value-of select="concat('---', $br)"/>
    <xsl:apply-templates select="tei:TEI/tei:teiHeader"/>
    <xsl:apply-templates select="tei:TEI/tei:text/tei:front"/>

    <xsl:value-of select="concat('---', $br)"/>

    <!-- todo: handle abstract and teaser -->

    <!-- todo: set order and clusters based on:
      dhq-journal/toc/toc.xml

      - one issue can have multiple clusters
      - list cluster editors
    -->

    <xsl:apply-templates select="tei:TEI/tei:text/tei:body"/>


      </xsl:result-document>
  </xsl:template>

  <xsl:function name="fn:field">
    <!-- function to output data as a yaml field for hugo page metadata -->
    <xsl:param name="name"/>
    <xsl:param name="value"/>

    <xsl:value-of select="concat($name, ': ', normalize-space($value), $br)"/>
  </xsl:function>

  <xsl:function name="fn:multilineField">    
     <xsl:param name="name"/>
    <xsl:param name="value"/>
     <xsl:value-of select="concat($name, ': |', $br, '   ', normalize-space($value), $br)"/>
  </xsl:function>

  <xsl:function name="fn:quotedField">
    <!-- function to output string data, with quotes, as
      a yaml field for hugo page metadata -->    
    <xsl:param name="name"/>
    <xsl:param name="value"/>
    <xsl:choose>
      <xsl:when test="contains($value, $quote)">
        <xsl:value-of select="fn:multilineField($name, $value)"/>                
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="fn:field($name, concat($quote, normalize-space($value), $quote))"/>        
      </xsl:otherwise>
    </xsl:choose>


    <!-- TODO: handle quotes in field content -->
    <!-- <xsl:variable name="content" select="replace($value, $quote, concat('\\', $quote))"/> -->
    <!-- <xsl:value-of select="fn:field($name, concat($quote, normalize-space($value), $quote))"/>     -->

  </xsl:function>

  <!-- Template for the TEI header -->
  <xsl:template match="tei:teiHeader">
    <!-- use article type for appropriate SW templates -->
    <xsl:value-of select="fn:field('type', 'article')"/>
    <!-- dhq type (article/editorial) -->
    <!-- FIXME: at least one article has articletype repeated; get the first -->
    <xsl:value-of select="fn:field('dhqtype', tei:fileDesc/tei:publicationStmt/dhq:articleType)"/>    
    <xsl:value-of select="fn:quotedField('title', tei:fileDesc/tei:titleStmt/tei:title)"/>
    <xsl:value-of select="fn:field('date', tei:fileDesc/tei:publicationStmt/tei:date/@when)"/>
    <!-- quote to preserve leading zeroes -->
    <xsl:value-of select="fn:quotedField('article_id', tei:fileDesc/tei:publicationStmt/tei:idno[@type='DHQarticle-id'])"/>
    <xsl:value-of select="fn:field('volume', tei:fileDesc/tei:publicationStmt/tei:idno[@type='volume'])"/>
    <xsl:value-of select="fn:field('issue', tei:fileDesc/tei:publicationStmt/tei:idno[@type='issue'])"/>

    <!-- author list -->
    <xsl:value-of select="concat('authors:', $br)"/>
    <xsl:apply-templates select="tei:fileDesc/tei:titleStmt/dhq:authorInfo" mode="metadata"/>
    <!-- keyword lists; map dhq keywords to categories and author keywords to tags -->
    <xsl:apply-templates select="tei:profileDesc//tei:keywords[@scheme='#dhq_keywords']"/>
    <xsl:apply-templates select="tei:profileDesc//tei:keywords[@scheme='#authorial_keywords']"/>
    <!-- TODO: set license when not default -->

  </xsl:template>

  <!-- convert front matter to page metadata -->
  <xsl:template match="tei:front">
    <xsl:value-of select="fn:multilineField('abstract', dhq:abstract)"/>    
    <xsl:value-of select="fn:quotedField('teaser', dhq:teaser)"/>        

  </xsl:template>


  <!-- output authors as markdown list for page yaml -->
  <xsl:template match="dhq:authorInfo" mode="metadata">
    <xsl:value-of select="concat('- ', normalize-space(dhq:author_name), $br)"/>
  </xsl:template>

  <xsl:template match="tei:keywords[@scheme='#dhq_keywords']">
    <!-- only output if there is text for at least one keyword -->
    <xsl:if test=".//tei:item/text()">
        <xsl:value-of select="concat('categories:', $br)"/>
      <xsl:apply-templates select=".//tei:item" mode="metadata"/>
    </xsl:if>
  </xsl:template>
  <xsl:template match="tei:keywords[@scheme='#authorial_keywords']">
    <!-- only output if there is text for at least one keyword -->
    <xsl:if test=".//tei:item/text()">
        <xsl:value-of select="concat('tags:', $br)"/>
        <!-- at least one article has items not nested under list -->        
      <xsl:apply-templates select=".//tei:item" mode="metadata"/>
    </xsl:if>
  </xsl:template>


  <xsl:template match="tei:item" mode="metadata">
    <xsl:if test="normalize-space(.)"> <!-- don't output empty items -->
      <xsl:value-of select="concat('- ', ., $br)"/>    
    </xsl:if>
  </xsl:template>

 

  <!-- Template for TEI keywords/terms -->
  <xsl:template match="term">
    <xsl:text>[</xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>]</xsl:text>
    <xsl:if test="position() != last()">
      <xsl:text>, </xsl:text>
    </xsl:if>
  </xsl:template>

  <!-- Template for the body -->
  <xsl:template match="tei:body">
    <xsl:apply-templates/>

    <xsl:apply-templates select=".//tei:note" mode="endnotes"/>
    <!-- todo: handle bibliography and bibliography pointers -->
  </xsl:template>

  <!-- paragraphs in markdown are indicated by line breaks -->
  <xsl:template match="tei:p|tei:div">
    <xsl:value-of select="$br"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

<!-- fixme: probably need to handle at cit/epigraph level -->
  <xsl:template match="tei:quote[@rend='block']">
    <xsl:value-of select="concat($br, '> ')"/>
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/>    
  </xsl:template>

  <xsl:template match="tei:quote[@rend='block']/tei:lb">
    <xsl:value-of select="concat($br, '> ')"/>
    <xsl:apply-templates/>
  </xsl:template>

  <!-- Template for titles -->
  <xsl:template match="tei:head">
    <xsl:value-of select="concat($br, '# ')"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

    <!-- Template for headings -->
  <xsl:template match="tei:div/tei:head">
    <xsl:value-of select="concat($br, $br, '## ')"/> 
    <xsl:apply-templates/>
    <xsl:value-of select="$br"/> 
  </xsl:template>

<xsl:template match="tei:list">
    <xsl:value-of select="$br"/> 
    <xsl:apply-templates/>    
    <xsl:value-of select="concat($br, $br)"/>     
  </xsl:template>


<xsl:template match="tei:note">
  <xsl:value-of select="concat('[^', count(preceding::tei:note) + 1, '] ')" />
</xsl:template>

<xsl:template match="tei:note" mode="endnotes">
  <xsl:value-of select="concat($br, '[^', count(preceding::tei:note) + 1, ']: ')" />  
  <xsl:apply-templates/>
</xsl:template>


<xsl:template match="tei:ptr">
  <!-- ptr with no text uses url for link text -->
  <xsl:value-of select="concat('[', @target, '](', @target, ')')"/>
</xsl:template>


<xsl:template match="tei:list[@type='unordered']/tei:item">
    <xsl:value-of select="concat($br, ' * ')"/> 
  <xsl:apply-templates/>      
</xsl:template>

<xsl:function name="fn:wrap">
    <xsl:param name="outer"/>
    <xsl:param name="inner"/>

    <xsl:value-of select="concat(' ' , $outer)"/>
    <xsl:for-each select="$inner">
      <xsl:apply-templates/>
    </xsl:for-each>
    <xsl:value-of select="concat($outer, ' ')"/>    
  </xsl:function>

  <xsl:function name="fn:wrap">
    <xsl:param name="firstOuter"/>
    <xsl:param name="inner"/>
    <xsl:param name="lastOuter"/>    

    <xsl:value-of select="concat(' ' , $firstOuter)"/>
    <xsl:for-each select="$inner">
      <xsl:apply-templates/>
    </xsl:for-each>
    <xsl:value-of select="concat($lastOuter, ' ')"/>    
  </xsl:function>

  <!-- Template for emphasis -->
  <xsl:template match="tei:hi[@rend='italic']|tei:title[@rend='italic']|tei:emph|tei:bibl[@style='italic']">
    <xsl:value-of select="fn:wrap('_', .)"/>
  </xsl:template>

  <!-- Template for bold -->
  <xsl:template match="tei:hi[@rend='bold']">
    <xsl:value-of select="fn:wrap('**', .)"/>
  </xsl:template>

  <!-- Template for code -->
  <xsl:template match="tei:code">
    <xsl:value-of select="fn:wrap('`', .)"/>    
  </xsl:template>

   <xsl:template match="tei:soCalled|tei:quote[@rend='inline']|tei:title[@rend='quotes']">
    <xsl:value-of select="fn:wrap('“', ., '”')"/>        
  </xsl:template>

  <!-- Template for links -->
  <xsl:template match="tei:ref[@type='web']">
    <xsl:text>[</xsl:text>
    <xsl:attribute name="href">
      <xsl:value-of select="@target"/>
    </xsl:attribute>
    <xsl:apply-templates/>
    <xsl:text>]</xsl:text>
  </xsl:template>

  <xsl:template match="text()" priority="2">
    <xsl:apply-templates select="normalize-space(.)"/>
  </xsl:template>

  <!-- Identity template to copy nodes as-is -->
  <xsl:template match="@*|element()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>



</xsl:stylesheet>
